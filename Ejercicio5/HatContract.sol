pragma solidity ^0.8.20;

contract HatFactory{

    struct Hat{
        //User defined name or automatic generated by the game
        string name;
        uint64 seed;
    }
    /*
    struct Hat{
        string name;
        //Basic infgo
        //Hat type
        uint8 base_hat;
        //Shader effect
        uint8 efect;
        //Hatable means how many hats the hat can have
        uint8 hatable;
        //Unbount variable pendent to revision
        uint8 hat_type;


        //color:
        uint8 r;
        uint8 g;
        uint8 b;
        uint8 a;

    }
    */

    Hat[] public hats;

    //Limitar la cantidad de cosmeticos generados por un usuario en base a su ultimo timestamp
    mapping (address => uint256) private lastGenCosmetic;
    uint cooldown = 900;


    mapping (uint => address) public hatToOwner;
    //mantener una lista de owner -> lista de gorros que tiene
    //debido a que en solidity eliminar un elemento de una lista es costoso
    //usamos un mapping + array + swap-and-pop para que la complejidad sea de O(1)

    //mapping address a una lista de hatids
    mapping (address=>uint256[]) private ownedHats;
    //mapping hatids a id de la lista del owner, id siempre será indice+1 ya que 0 indica null
    mapping (uint256 => uint256) private hatOwnerInvId;
    //Cuando hablamos de index hablamos de id-1



    //Envía un hat a otra persona
    function sendHat(uint256 hatId, address sendTo) public {
        require(hatToOwner[hatId] == msg.sender, "No eres el duenho");
        //eliminamos el hat del inventario
        removeHat(hatId);
        //Añadir el hat al nuevo address
        hatToOwner[hatId] = sendTo;
        //Añdir el hat al inventario del nuevo address
        ownedHats[sendTo].push(hatId);
        //no restamos 1 para preservar 0 como id especial
        hatOwnerInvId[hatId] = ownedHats[sendTo].length;
    }

    // Eliminar un hat del inventario
    //esta funcion simplemente es una prueba, en proximas entregas se reimplementará
    //para transferencia de hats entre usuarios
    //simplemente es una demostración de como eliminar el hat del inventario
    //de manera eficiente
    function removeHat(uint256 hatId) public {
        require(hatToOwner[hatId] == msg.sender, "No eres el duenho");
        //Obtenelos el index del hat a eliminar
        uint256 index = hatOwnerInvId[hatId]-1;
        //Obtenemos el id del ultimo hat
        uint256 lastHatId = ownedHats[msg.sender][ownedHats[msg.sender].length - 1];

        // Swap-and-pop para eliminar en O(1)
        // al hat a eliminar le ponemos la id del hat final
        ownedHats[msg.sender][index] = lastHatId;
        // en el mapping establecemos su nuevo index
        hatOwnerInvId[lastHatId] = index+1;

        //popeamos el ultimo hat
        ownedHats[msg.sender].pop();
        //Eliminamos del mapping de id (id se pone a 0 es decir null)
        delete hatOwnerInvId[hatId];
        //Eliminamos del mapping de owner
        delete hatToOwner[hatId];
    }

    // Obtener todos los productos de un owner
    function getProductsByOwner(address owner) public view returns (uint256[] memory) {
        return ownedHats[owner];
    }


    function _createHat(string memory _name, uint64 _seed) private {
        //Añadir el hat a la lista de hats
        hats.push(Hat(_name,_seed));
        uint256 id = hats.length-1;
        
        //Añadir el hat al mapping de hat to owner
        hatToOwner[id] = msg.sender;
        //Añdir el hat al inventario del owner
        ownedHats[msg.sender].push(id);
        //no restamos 1 para preservar 0 como id especial
        hatOwnerInvId[id] = ownedHats[msg.sender].length;
        //Establecer cuando fue la ultima vez que se creó un hat para ese owner
        lastGenCosmetic[msg.sender] = block.timestamp;

    }

    function _generateRandomSeed() private view returns (uint256){
        //Esto es inseguro para cosas con valor y sería mejor usar un oráculo
        return uint256(keccak256(abi.encodePacked(block.timestamp, hats.length, msg.sender)));
    }

    function createRandomHat(string memory _name) public {
        require(lastGenCosmetic[msg.sender]+cooldown <= block.timestamp, "Has llegado al limite de sombreros, espera antes de generar uno nuevo");
        _createHat(_name,uint64(_generateRandomSeed()%type(uint64).max));
    }
}
